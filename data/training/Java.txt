public class ATOI {

	/*public static void main(String arg[]) {
		String str = "-1343";
		Integer result = convertAtoI(str);
		if (result != null)
			System.out.println(result);
		else
			System.out.println("Not a number");
	}

	public static Integer convertAtoI(String str) {
		Integer value = 0;
		boolean isNegative = false;
		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == '-') {
				if (i == 0)
					isNegative = true;
				else
					return null;
			} else {
				int tmp = str.charAt(i) - '0';
				if (tmp >= 48 && tmp <= 57) {
					return null;
				}
				System.out.println("temp ->" + tmp);
				value = (value * 10) + tmp;
				System.out.println("value ->" + value);
			}
		}
		if(isNegative)
			return -1*value;
		//if (RectA.X1 < RectB.X2 && RectA.X2 > RectB.X1 &&
       //RectA.Y1 < RectB.Y2 && RectA.Y2 > RectB.Y1) 
		return value;
	}*/
	
	public static void main(String args[]){
		String test1 = "hello";
		test1+="world";
		System.out.println(test1);		
	}

}
class BST{
BST rchild= null;
BST lchild= null;
Integer value = null;
}

class BSTTest {
	public static void main(String args[]) {
		BST root = null;
		// 12,233,32,11,3,3
		root = makeBST(12, root);
		// printBST(root);

		makeBST(233, root);
		// printBST(root);

		makeBST(32, root);
		// printBST(root);

		makeBST(11, root);
		// printBST(root);

		makeBST(3, root);
		// printBST(root);

		root = makeBST(3, root);
		printBST(root);

		/*
		 * 12 11 233 3 32
		 */
	}

	public static BST makeBST(int value, BST root) {
		if (root == null) {
			root = new BST();
			root.value = value;
		} else {
			if (root.value < value) {
				root.rchild = makeBST(value, root.rchild);
			} else if (root.value > value) {
				root.lchild = makeBST(value, root.lchild);
			}
		}
		return root;
	}

	public static Boolean printBST(BST root) {
		if (root != null) {
			printBST(root.lchild);
			System.out.println(root.value);
			printBST(root.rchild);
		}
		return true;
	}
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class DepthString{
	
 public static void main(String args[]){
	 System.out.println(find_depth("(00)x"));
 }
	
  public static int find_depth(String tree) {
		   
		   if(tree == null || tree.length() < 4 || tree.charAt(0) != '(') {
		       return -1;
		   }
		   
		   int height = 0;
		   int lengthOfString = tree.length();
		   int isBalanced = 0;
		   int countZeros = 0;
		   
		   for(int i = 0 ; i < lengthOfString; i++) {
		       char c = tree.charAt(i);
		       if(c == '0' || c == '(' || c == ')') {
		          if( c == '(' ) {
		              isBalanced++;
		              
		          } else if ( c == ')') {
		              isBalanced--;
		          } else {
		              countZeros++;
		          }   
		       } else  {
		           return -1;
		       }
		   }
		   boolean value = hasRoot(tree);
		   if(isBalanced == 0 && countZeros >= 2 && value) {
		        if(tree.matches("\\(\\(00\\)0\\)")) {
		            return 1;
		        }
		        // find number of "(0" and return count -1 as dept.
		       Pattern pattern = Pattern.compile("\\(0");
		       Matcher matcher = pattern.matcher(tree);
		       while(matcher.find()) {
		    	   height++;
		       }
		   }
		   return height-1;
		   }
		   
		   private static boolean hasRoot(String str) {
		       // Find if it contains following sequence.
		       return str.contains("(00)");
		   }

}


public class LongestCommonSubString {
	
	
	public static void main(String args[]) {
      String str1 = "Hi this is raghavan speaking about text finding later we can speak about dog, this wehre dogs come";
      String str2 = "dog about come";
      String smallString,largeString;
      Integer maxSet=0;
      String maxMatchStr=new String();
      
      if(str1.length() <= str2.length()){
    	 smallString = str1;
    	 largeString = str2;
     }else{
    	 smallString = str2;
    	 largeString = str1;
     }
     	 
      Integer strMatrix[][] = new Integer[largeString.length()+1][smallString.length()+1];
      
     for(int i = 0;i<largeString.length()+1;i++){
    	 for(int j=0;j<smallString.length()+1;j++){
    		 strMatrix[i][j] = 0;
    	 }
     }
      
     for(int i = 0;i<largeString.length();i++){
    	 for(int j=0;j<smallString.length();j++){
    		 if(largeString.charAt(i) == smallString.charAt(j)){    			 
    			 strMatrix[i+1][j+1] =  strMatrix[i][j] +1;    			
    			 if(strMatrix[i+1][j+1]>maxSet){
    				 maxSet = strMatrix[i+1][j+1];
    				 //printMatrix(strMatrix,largeString.length(), smallString.length());
    				 maxMatchStr = alterSetValue(strMatrix, i+1,j+1,largeString);
    			 }
    		 }
    	 }
     }
     System.out.println("Longest Common Sub Sequence is = "+maxMatchStr);
	}
	
	private static void printMatrix(Integer matrix[][],int row,int col){
		for(int i=0;i<row;i++){
			for(int j=0;j<col;j++){
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}

	}

	private static String alterSetValue(Integer strMatrix[][], int i,int j,
			String largeStr) {
		int currentval =  strMatrix[i][j];		
		StringBuilder maxMatchStrBuilder = new StringBuilder();
		while(currentval>0){
			i--;
			currentval --;
			//System.out.println("concating = "+largeStr.charAt(i));
			maxMatchStrBuilder.append(String.valueOf(largeStr.charAt(i)));;
		}
		//System.out.println("Max str ="+maxMatchStrBuilder);
		//System.out.println("-------------");
		return maxMatchStrBuilder.reverse().toString();
		
	}
}


class Permute {
	public  static void main(String ars[]) { 
	    permutation("","30 40 20"); 
	 }

	 private static void permutation(String prefix, String str) {
	    int n = str.length();
	    if (n == 0) 
	    	System.out.println("Result => "+prefix);
	    else {
	    	//System.out.println(" Str -->"+str + " prefix  --> "+prefix);	    	
	        for (int i = 0; i < n; i++){
	        	String intPrefix = new String(prefix + str.charAt(i));
	        	String firstHalf = str.substring(0, i);
				String secondHald = str.substring(i+1, n);
	        	String swappedStr = new String(firstHalf+secondHald);	           
	        	//System.out.println("Prefix --> "+intPrefix+" swappedstr --> ("+ firstHalf+") + ("+secondHald+")\n\n");
	        	permutation(intPrefix, swappedStr);
	        }
	    }

	}

}
public class PrintText {
	public static void main(String[] args) {
		String input = "Cracking the Coding Interview: 150 Programming Interview Questions and Answers focuses on mastering the programming interview. Topics include: strategies to handle tough algorithm questions, preparation techniques, behavioral questions, and 150 programming interview questions and answers.";
		StringBuilder sb = makeLeftAlign(input);
		
		System.out.println(sb);
	}

	private static StringBuilder makeLeftAlign(String input) {
		int width = 20;
		int pos = 0;
		StringBuilder sb = new StringBuilder();
		
		String[] words = input.split(" ");
		for (String w : words) {
			if (pos + w.length() > width) {
				sb.append('\n');
				pos = 0;
			}
			sb.append(w);
			sb.append(' ');
			pos += w.length() + 1;
			
		}
		return sb;
	}
}

public class RunLengthEncoding {

	public static void main(String args[]){
		String str = "aaaabbcss";
		
		int count = 0;
		Character prevChar=null;
		for(int i=0;i<str.length();i++){
			if(prevChar == null){
				prevChar = str.charAt(i);
				count+=1;
			}else if(str.charAt(i) == prevChar){
				count+=1;
			}else if(str.charAt(i) != prevChar){
				System.out.print(prevChar.toString()+count);
				prevChar = str.charAt(i);
				count=1;
			}
		}
		System.out.println(prevChar.toString()+count);
	}
}
public class SpiralMatrix {
	public static void main(String args[]) {
		int row = 4, col = 4;
		String matrix[][] = { { "A", "B", "C", "D" }, { "E", "F", "G", "H" },
				{ "I", "J", "K", "L" }, { "M", "N", "O", "P" }};
		int noItems = row * col;
		int rowStretch = row, colStretch = col-1;

		int i = 0, j = 0;

		while (noItems > 0) {

			for (int ctr=0; ctr < rowStretch; ctr++) {
				print(matrix, i, j);
				noItems--;
				j++;
			}
			rowStretch -= 1;
			i++;
			j--;
			//System.out.println("Row Stretch = "+rowStretch);
			
			for (int ctr=0;ctr < colStretch;ctr++) {
				print(matrix, i, j);
				noItems--;
				i++;
			}
			colStretch -= 1;
			i--;
			j--;
			//System.out.println("Col Stretch = "+colStretch);

			print(i, j);
			for (int ctr=0;ctr<rowStretch;ctr++) {
				print(matrix, i, j);
				noItems--;
				j--;
			}
			rowStretch -= 1;
			i--;
			j++;
			//System.out.println("Row Stretch = "+rowStretch);

			print(i, j);
			for (int ctr=0; ctr < colStretch;ctr++) {
				print(matrix, i, j);
				noItems--;
				i--;
				print(i, j);
			}
			i++;
			j++;
			colStretch -= 1;
			//System.out.println("Col Stretch = "+colStretch);

		}
	}

	private static void print(int i, int j) {
		//System.out.println("Position = " + i + " " + j);
	}

	private static void print(String matrix[][], int i, int j) {
		System.out.println(matrix[i][j]);
	}
}
public class StringMatcher {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		System.out.println(getSubStrPos("Raghavan", "r"));

	}

	public static int getSubStrPos(String str, String subStr){
		str = str.toLowerCase();
		subStr = subStr.toLowerCase();
		
		if((str == null && subStr == null) || (str.isEmpty() && subStr.isEmpty()))
			return 1;
		
		if(str == null || subStr == null || str.isEmpty() || subStr.isEmpty())
			return -1;
		
		for(int i=0;i<str.length();i++){	
			int j=i;
			for(int k=0;k<subStr.length();k++){
				if(str.charAt(j) == subStr.charAt(k)){					
					j++;
				}else{				
					break;
				}
			}			
			if((j-i) == subStr.length()){
				return i+1;
			}		
		}
		return -1;
	}

}

public class StringPermute {
	
static void print(Integer v[],  int size)
{
  if (v != null) {
    for (int i = 0; i < size; i++) {
      System.out.print( v[i] );
    }
    System.out.println();
  }
} // print

static int level = -1;
static void visit(Integer Value[], int k)
{
 int N = Value.length;
  level = level+1; 
  Value[k] = level;
  if (level == N)
    print(Value, N);
  else
    for (int i = 0; i < N; i++)
      if (Value[i] == 0)
        visit(Value, i);

  level = level-1; Value[k] = 0;
}


public static void main(String args[])
{
  int N = 4;
  Integer Value[] = new Integer[N];
  for (int i = 0; i < N; i++) {
    Value[i] = 0;
  }
  visit(Value, 0);
}

}
import tree.Tree;


public class TestLearn1 {

	public static void main(String args[]){
		Tree<String> tree = new Tree<String>("livingthings");
		tree.addLeaf("livingthings","animals");
		tree.addLeaf("animals","mammal");
		tree.addLeaf("livingthings","plants");
		tree.addLeaf("human","good");
		tree.addLeaf("livingthings","human");
		tree.addLeaf("human","bad");
		System.out.println(tree.getSuccessors("human"));
		
	}
	
	public static void print(Object o){
		System.out.println(o.toString()+ " as object");
	}

	public static void print(Integer i){
		System.out.println(i + " as integer");
	}
	
	public static String removeUnderscore(String str){
		boolean underScoreHit = false;
		StringBuffer newString = new StringBuffer();
		for(int i=0;i<str.length();i++){
			if(str.charAt(i) == '_' && !underScoreHit){
				underScoreHit = true;
				newString.append(str.charAt(i));
			}else{
				if(str.charAt(i) != '_'){
					underScoreHit = false;
					newString.append(str.charAt(i));
				}
			}
		}
		
		return newString.toString();
	}
	
}
public class sqrtNumber {
	public static void main(String[] args) {
		System.out.println(calcSqrt(5));
	}

	private static float calcSqrt(int number) {
		int k = 1;
		while (k * k <= number) {
			k++;
		}
		if (k != 1) {
			k--;
		}
		if (k * k == number) {
			return k;
		}
		float oldGuess = k;
		float newGuess = k;
		do {
			oldGuess = newGuess;
			newGuess = getNewGuess(oldGuess, number);
		} while (newGuess - oldGuess > 0.0001);
		return newGuess;

	}

	private static float getNewGuess(float oldGuess, int number) {
		float newGuess = number / oldGuess;
		return (oldGuess + newGuess) / 2;
	}

}package com.mxgraph.examples.swing;

import javax.swing.JFrame;

import com.mxgraph.swing.mxGraphComponent;

public class ClickHandler extends JFrame {

	private static final long serialVersionUID = -2764911804288120883L;

	public ClickHandler(final mxGraphComponent graphComponent) throws Exception {
		super("Polarity Inconsistency Supporter");		
		getContentPane().add(graphComponent);
	}

}
package util;

public interface Constants {
	/*
	final static String WORD_POLARITY_SRC_FILENAME = "3in1_noun.properties";
	public static final String INCONSISTENT_POLAIRY_OUTPUT_FILE = "output_noun.txt";
	String WORDNET_SENSES_FREQ = "wordnet_sense_freq_noun.properties";
	String EXISTING_INCONST_PROP = "InconsistentWordPolarity_noun.properties";
	String OUTPUT_PROP_FILE = "UpdatedWordPolarity_noun.properties";
	String EXISTING_INCONST_PROP_CAMBRIDGE = "InconsistentWordPolarity_cambridge_noun.properties";
	*/

	final static String WORD_POLARITY_SRC_FILENAME = "3in1_adj.properties";
	public static final String INCONSISTENT_POLAIRY_OUTPUT_FILE = "output.txt";
	String WORDNET_SENSES_FREQ = "wordnet_sense_freq.properties";
	String EXISTING_INCONST_PROP = "InconsistentWordPolarity.properties";
	String OUTPUT_PROP_FILE = "UpdatedWordPolarity.properties";
	String EXISTING_INCONST_PROP_CAMBRIDGE = "InconsistentWordPolarity_cambridge.properties";
	
	
	
	
	String WELCOME_NOTE = "Welcome to Word Polarity Support Tool\n\n\t \bInstruction to use this tool:\n";
	String WELCOME_INSTRUCTIONS = 	"\n1.Click Start to enter the application.\n" +
			"\n\t2.Clicking Next/Back will move through the set of conflicting words.\n" +
			"\n\t3.Senses/Words can be moved along the screen for ease of visualization.\n" +
			"\n\t4.If Word is clicked the Polarity keeps on Changing \n (For Ex.1st Click change to Positive, next click to Negative and keep changing)\n" +
			"\n\t5.Save button helps to save the changes intermittently to avoid data loss" +
			"" +
			"\n\n\tDesigned By," +
			"\n\tRaghavan KL" +
			"\n\tPradeepa" +
			"\n\tKeerthika";
}
package util;

public enum DictionaryName {

	CAMBRIDGE_DICTIONARY("Cambrige Dictionary"),
	OXFORD_DICTIONARY("Oxford Dictionary"),
	WORDNET_DICTIONARY("WordNet");
	
	public String value;

	private DictionaryName(String name) {
		this.value = name;
	}
	
	public static DictionaryName fromString(String name) {
		if (name != null) {
			for (DictionaryName b : DictionaryName.values()) {
				if (name.equalsIgnoreCase(b.value)) {
					return b;
				}
			}
		}
		return null;
	}


}
package util;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;

public class HttpHandlerUtil {
	
	public static String getHTML(String urlToRead) {
		//System.out.println("Url to read ="+ urlToRead);
	      URL url;
	      HttpURLConnection conn;
	      BufferedReader rd;
	      String line;
	      String result = "";
	      try {
	         url = new URL(urlToRead);
	         conn = (HttpURLConnection) url.openConnection();
	         conn.setRequestMethod("GET");
	         rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
	         while ((line = rd.readLine()) != null) {
	            result += line;
	         }
	         rd.close();
	      } catch (Exception e) {	         
	      }
	      return result;
	   }

	public static final String URL_PRE_QUERY = "https://dictionary.cambridge.org/api/v1/dictionaries/american-english"
			+ "/search/first/?q=";
	public static final String URL_POST_QUERY = "&format=xml&_dc=1352703470685&page=1&start=0&limit=25";

	public static void main(String args[]) {
		getResponse("large");
	}

	public static String getResponse(String word) {
		HttpClient client = new DefaultHttpClient();
		HttpGet request = new HttpGet(URL_PRE_QUERY + word + URL_POST_QUERY);

		//Its a key which we can get when registering with cambridge apis
		request.setHeader("accessKey",
				"bwzcf97b1Zl3rRqygxjrQdnKXkccyrBp7qn7UvXxwB7HqwoABbnO2lhZ6kSCkMkP"); 
		request.setHeader("accept", "application/json");

		HttpResponse response;
		// Get the response
		BufferedReader rd;
		try {
			response = client.execute(request);
			rd = new BufferedReader(new InputStreamReader(response.getEntity()
					.getContent()));
			String line = new String();
			StringBuffer responseStringBuf = new StringBuffer();
			while ((line = rd.readLine()) != null) {
				//System.out.println(line);
				responseStringBuf.append(line);
			}
			return responseStringBuf.toString();
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static String getEntryUrlUsingApi(String word) {
		String response = getResponse(word);
		return null;
		//StringHandlerUtil.getStringBetweenPattern(response, <, endPattern)
	}
}
package util;

public enum Polarity {
	Positive(1), Negative(2), Neutral(3), UnChanged(4);

	int value;

	Polarity(int value) {
		this.value = value;
	}

	public static String fromValue(int a) {
		for(Polarity polarity : Polarity.values()){
			if(polarity.value == a){
				return polarity.toString();
			}
		}
		return null;
	}

}
package util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StringHandlerUtil {

	public static List<String> getStringBetweenPattern(String text,String startPattern,String endPattern){
			List<Integer> positions = new ArrayList<Integer>();
			List<String> definitions = new ArrayList<String>();
			Pattern p = Pattern.compile(startPattern);
			Matcher m = p.matcher(text);
			while (m.find()) {
			   positions.add(m.start());
			}
			for(Integer pos : positions){
				Pattern endPointPattern = Pattern.compile(endPattern);	
				Matcher endPointMatcher =  endPointPattern.matcher(text.substring(pos+startPattern.length()));			
				if(endPointMatcher.find()){
					int endPoint =  endPointMatcher.start();
					String def = text.substring(pos+startPattern.length(),pos+startPattern.length()+endPoint);
					definitions.add(def);
				}
			}
			return definitions;

	}
	
	public static String makeLeftAlign(String input) {
		int width = 200;
		int pos = 0;
		StringBuilder sb = new StringBuilder();
		
		String[] words = input.split(" ");
		for (String w : words) {
			if (pos + w.length() > width) {
				sb.append('\n');
				pos = 0;
			}
			sb.append(w);
			sb.append(' ');
			pos += w.length() + 1;
			
		}
		return sb.toString();
	}
	
	public static String makeFirsLetterCaps(String str){
		if(str == null)
			return null;
		return str.substring(0, 1).toUpperCase() + str.substring(1);
	}
	
}
package dm.algorithms.msgsp;

import java.io.Serializable;
import java.util.ArrayList;



public class ItemSet implements Serializable{

	private ArrayList<String> items= new ArrayList<String>();
	private int count=0;
	
	public ItemSet(){
	}
	
	
	public int getCount() {
		return count;
	}


	public void setCount(int count) {
		this.count = count;
	}


	public ArrayList<String> getItems() {
		return items;
	}


	public void setItems(ArrayList<String> items) {
		this.items = items;
	}
	
	public void addItem(String str){
		items.add(str);
	}
	
		
	
@Override
public boolean equals(Object obj){
	if(obj==null) return false;
	if(getClass()!=obj.getClass()) return false;
	ItemSet itemSet= (ItemSet)obj;
	if(this.items.size()!=itemSet.getItems().size()) return false;
	for(int i=0;i<this.items.size();i++)
		if(this.items.get(i).equals(itemSet.getItems().get(i))) continue;
		else return false;
	return true;
}

public String getFormattedItemString(){
	String format="";
		for(String x:this.getItems())
			format=format+","+x;
	return format.substring(1,format.length());
}


@Override
public String toString() {
	return this.getFormattedItemString();
}


public boolean contains(ItemSet toBeMatchedItemSet) {
	
	int matchIdx=0;
	for(int i=0;i<this.getItems().size();i++){
		if(matchIdx==toBeMatchedItemSet.getItems().size()) break;
		if(this.getItems().get(i).equals(toBeMatchedItemSet.getItems().get(matchIdx))){
			matchIdx++;
		}
	}
		
	return matchIdx==toBeMatchedItemSet.getItems().size();
}



}
package dm.algorithms.msgsp;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import dm.algorithms.msgsp.inputimpl.FileInputReaderImpl;
import dm.algorithms.msgsp.model.MISMap;
import dm.algorithms.msgsp.model.SequenceIndex;

/**
 * MS-GSP Algorithm - For DataMining CS 583 (Dr. Bing)
 * 
 * 
 * 
 * @author Raghavan KL
 * @author Venkat Raghavan
 * 
 */
public class MSGSP {

	private static float numTrans = 0;
	public static float SDC = 0f;
	public static final float epsilon=0.00009f;
	ArrayList<Sequence> L = new ArrayList<Sequence>();
	HashMap<String,Float> itemMinSups = new HashMap<String,Float>();
	HashMap<Integer, ArrayList<Sequence>> sequencePatterns = new HashMap<Integer, ArrayList<Sequence>>();
	
	private void execute(File transactionFile, File paramFile,boolean createOutput) {
		FileInputReaderImpl fileReader = new FileInputReaderImpl();
		ArrayList<Transaction> transactions = (ArrayList<Transaction>) fileReader
				.getTransactions(transactionFile);
		Map<String, Float> misValueMap = fileReader.makeMISMap(paramFile);
		MISMap.minSupportMap = misValueMap;
		numTrans = (float) transactions.size();
		doMSGSP(transactions);
		
		if(createOutput) {
			String fileName=paramFile.getName().replace("para", "result");
			Output.writeToFile(transactionFile.getParent()+"/"+fileName, sequencePatterns);
		}
	}

	public ArrayList<Sequence> initialPass(ArrayList<Transaction> transactions) {

		// 1) Generate F1 - Same as Apriori - Return to doMSGSP
		ArrayList<Sequence> f1 = new ArrayList<Sequence>();
		ArrayList<String> orderedMISItems = (ArrayList<String>) MISMap
				.getItemsInAscOrderOfMinSup();
		HashMap<String, Integer> freqSet = new HashMap<String, Integer>();

		//Initialize freqSet
		for (String item : orderedMISItems) {
			freqSet.put(item, 0);
		}
		
		
		for (Transaction t : transactions) {
			Sequence s = t.getSequence();
			HashSet<String> removeRepeated = new HashSet<String>(); // Count
																	// only once
																	// for each
																	// Customer
			for (String item : s.getAllItems()) {
				if (!removeRepeated.contains(item)) { // TODO - move this code
														// to sequence class -
					removeRepeated.add(item);
					freqSet.put(item, freqSet.get(item) + 1);
				}
			}

		}
		
		//Create L
		boolean first=true;
		String firstItem="";
		for (String item : orderedMISItems) {
			
			Sequence s = new Sequence();
			ItemSet is = new ItemSet();
			is.addItem(item);
			is.setCount(freqSet.get(item)); // Set count for the item
			s.setCount(freqSet.get(item)); // count for 1 level sequence
			s.addItemSet(is);
			s.computeLowestMISItemSupport(); // Compute min Sup
			s.setSequenceSupport(freqSet.get(item) / numTrans);
			itemMinSups.put(item, new Float(s.getSequenceSupport()));
			if(first){
			if (s.getSequenceSupport() >= (MISMap.getMinSupport(item)-epsilon)){
				first=false;
				firstItem=item;
				L.add(s);
			}
			}else{
				if(s.getSequenceSupport()>= (MISMap.getMinSupport(firstItem)-epsilon)){
					L.add(s);
				}
			}
		}
		
		//Create F1
		for(Sequence s:L)
		if (s.getSequenceSupport() >= (MISMap.getMinSupport(s.getFirstItem())-epsilon)){
			f1.add(s);
		}
		

		return f1;
	}

	private static void p(Object x) {
		System.out.println(x);

	}

	/**
	 * Performs MSGSP over Data sequences
	 * 
	 * 
	 * 
	 * @param transactions
	 * @param itemsWithMS
	 * @return
	 */

	public HashMap<Integer, ArrayList<Sequence>> doMSGSP(
			ArrayList<Transaction> transactions) {
		long startMSGSP = System.currentTimeMillis();
		
		
		int fCount = 1; // F1, F2....

		// 1) Sort itemsWithMS ==> sortedMinSupItems
		
		// 2) Call initPass and get F1
		ArrayList<Sequence> F1 = initialPass(transactions);
		// Output.printForBing(F1, fCount); // DEBUG
		sequencePatterns.put(fCount, F1);
		fCount++;
		while (sequencePatterns.get(fCount - 1) != null
				&& sequencePatterns.get(fCount - 1).size() != 0) {
			ArrayList<Sequence> sequences = new ArrayList<Sequence>();
			if (fCount == 2) {
				// Fig 2.13
				/**
				 * Join:: Remove "first" element from ItemSet1 and "last"
				 * element from ItemSet2. If : element from ItemSet2 is
				 * seperate, it WILL BE seperate in the joined sequence.
				 * Eg:<{1,2}{4}> & <{2}{4}{6}> ==> <{1,2}{4}{6}> If : element
				 * from ItemSet2 is in "merged" set, it will be merged to the
				 * sequence of ItemSet1 Eg: <{1,2}{4}> & <{2}{4,5}> ==>
				 * <{1,2}{4,5}>
				 * 
				 * 
				 * 
				 */
				sequences = doLevel2SPM(L);
			} else {
				// Fig 2.15
				sequences = doMsSPM(sequencePatterns.get(fCount - 1));
			}

			// Filter Candidates
			ArrayList<Sequence> filteredCandidates =  filterCandidates(sequences, transactions);
			sequencePatterns.put(fCount, filteredCandidates);
		//	Output.printForBing(sequencePatterns.get(fCount), fCount);
			fCount++;
		}
		long endMSGSP   = System.currentTimeMillis();
		
		System.out.println("Total execution time is "+(endMSGSP-startMSGSP)/1000f+" s");
		
		 for(int i=1;i<fCount;i++){
		  Output.printForBing(sequencePatterns.get(i),i); }

		 

		return sequencePatterns;
	}

	/**
	 * Drops the desired index and check if the remaining items are equal. true
	 * ==> equal false ==> notEqual
	 * 
	 * @param itemSet1
	 * @param dropIndex1
	 * @param itemSet2
	 * @param dropInde2
	 * @return
	 */
	private boolean isSubsetEqual(String[] itemSet1, int dropIndex1,int dropIndex2,
			String[] itemSet2) {
		if (itemSet1 == null | itemSet2 == null)
			return false;
		String subset1 = "";
		String subset2 = "";

		for (int i = 0; i < itemSet1.length; i++) {
			if (i != dropIndex1)
				subset1 = subset1 + "," + itemSet1[i];
		}
		if (!subset1.equals(""))
			subset1 = subset1.substring(1, subset1.length());

		if(dropIndex2==-1)
		for (int i = 0; i < itemSet2.length - 1; i++) {
			subset2 = subset2 + "," + itemSet2[i];
		}
		else
			for (int i = 0; i < itemSet2.length; i++) {
				if (i != dropIndex2) subset2 = subset2 + "," + itemSet2[i];
			}	
		if (!subset2.equals(""))
			subset2 = subset2.substring(1, subset2.length());

		return subset1.equals(subset2);

	}

	/**
	 * 
	 * True ==> last item of Sequence 2 > last item of Sequence 1
	 * 
	 * @param s1
	 * @param s2
	 * @return
	 */
	private boolean compareLastLastLexic(Sequence s1, Sequence s2) {
		String item1 = s1.getLastItem();

		String item2 = s2.getLastItem();

		return Integer.parseInt(item2)>Integer.parseInt(item1)? true : false;

	}

	/**
	 * 
	 * True ==> if last item of Sequence 2 > first item of Sequence 1 False ==>
	 * if not.
	 * 
	 * @param s1
	 * @param s2
	 * @return
	 */
	private boolean compareFirstLastItemMIS(Sequence s1, Sequence s2) {

		float s1Mis = MISMap.getMinSupport(s1.getFirstItem());
		float s2Mis = MISMap.getMinSupport(s2.getLastItem());

		return s2Mis > s1Mis;

	}

	/**
	 * Check if first element of a sequence is min than all.
	 * 
	 * @param c
	 * @return
	 */
	private boolean isLastMisMinimum(Sequence c) {
		double minSup = MISMap.getMinSupport(c.getLastItem());
		ArrayList<String> items = c.getAllItems();
		for (int i = 0; i < items.size() - 1; i++)
			if (MISMap.getMinSupport(items.get(i)) <= minSup)
				return false;
		return true;
	}

	/**
	 * Check if first element of a sequence is min than all.
	 * 
	 * @param c
	 * @return
	 */
	private boolean isFirstMisMinimum(Sequence c) {
		double minSup = MISMap.getMinSupport(c.getFirstItem());
		ArrayList<String> items = c.getAllItems();
		for (int i = 1; i < items.size(); i++)
			if (MISMap.getMinSupport(items.get(i)) <= minSup)
				return false;
		return true;
	}

	/**
	 * 1 ==> suffix last item in s2 is separate 2 ==> last item in s2 is merged with
	 * another itemSet, 
	 * 3==> prefix first item in s2 to s1 as separate.
	 * 4 ==> prefix first item in s2 to s1 as merged.
	 * 
	 * 
	 * @param s1
	 * @param s2
	 * @param condition
	 * @return
	 */
	private Sequence mergeSequences(Sequence s1, Sequence s2, int condition) {

		Sequence newSequence = s1.copy();
		
		if (condition == 1) {
			ItemSet itemset = new ItemSet();
			ArrayList<String> item = new ArrayList<String>();
			item.add(s2.getLastItem());
			itemset.setItems(item);

			newSequence.addItemSet(itemset);

		} else if (condition == 2) {
			ArrayList<ItemSet> itemsets = newSequence.getItemSet();
			itemsets.get(itemsets.size() - 1).getItems().add(s2.getLastItem());
			newSequence.setItemSet(itemsets);
		} else if (condition == 3) {
			ItemSet itemset = new ItemSet();
			ArrayList<String> item = new ArrayList<String>();
			item.add(s2.getFirstItem());
			itemset.setItems(item);
			newSequence.prefixItemSet(itemset);
		} else if (condition == 4) {
			ArrayList<ItemSet> itemsets = newSequence.getItemSet();
			itemsets.get(itemsets.size() - 1).getItems().add(0, s2.getFirstItem());
			newSequence.setItemSet(itemsets);
		}
		newSequence.computeLowestMISItemSupport();
		
		if(newSequence.isThereDuplicateItemInAnyItemSet())
			return null;

		return newSequence;
	}

	public boolean isSequenceFrequent(Sequence s, ArrayList<Sequence> prevFreq) {
		List<Sequence> subSequences = new ArrayList<Sequence>();
		subSequences = generateSizeMinus1Sequences(s);
		int correctCount = 0;
		String strictlyLowestMISItem=s.getLowestMISItem();
		for (Sequence subSequence : subSequences) {
			for (Sequence prevF : prevFreq) {
				 //System.out.println(prevF.getFormattedSequence()+":::"+subSequence.getFormattedSequence());
				if(!subSequence.getAllItems().contains(strictlyLowestMISItem)){ correctCount++; break;} // Last line in prune
				if (prevF.isTheSequenceContainedInSameOrder(subSequence)) {
					correctCount++;
					break;
				}
				
			}
		}
		return correctCount == subSequences.size(); 
	}

	public List<Sequence> generateSizeMinus1Sequences(Sequence srcSequence) {
		//System.out.println("###"+srcSequence);
		if (srcSequence.getAllItems().size() <= 1) {
			List<Sequence> outPutSeq = new ArrayList<Sequence>();
			outPutSeq.add(srcSequence);
			return outPutSeq;
		}
		int expectedSeqSize = srcSequence.getSequenceLength() - 1;
		List<ItemSet> permuteds = Util.allPossibleCustomPermutation(srcSequence
				.getAllItems());
		List<Sequence> sequences = seqMinus1RuleSet(srcSequence,
				expectedSeqSize, permuteds);
		return sequences;

	}

	private List<Sequence> seqMinus1RuleSet(Sequence srcSequence,
			int expectedSeqSize, List<ItemSet> permuteds) {

		List<Sequence> sequences = new ArrayList<Sequence>();
		Map<String, Integer> permuteCombinationCount = new HashMap<String, Integer>();
		for (ItemSet item : permuteds) {
			int count = 1;
			if (permuteCombinationCount.containsKey(item.toString())) {
				count += permuteCombinationCount.get(item.toString());
			}
			permuteCombinationCount.put(item.toString(), count);
			Sequence seq = new Sequence();
			ItemSet itemSet = new ItemSet();
			int prevListNumber = -1, prevIndexNumber = -1;
			boolean canAdd = true;
			for (String str : item.getItems()) {
				/*int currentListNumber = srcSequence.checkNthElementListNumber(
						str, prevListNumber,
						permuteCombinationCount.get(item.toString()));*/
				int currentIndexNumber = srcSequence
						.checkNthElementIndexNumber(str, prevIndexNumber + 1,
								permuteCombinationCount.get(item.toString()));
				int currentListNumber = srcSequence.getItemSetNumberGivenItemIndex(currentIndexNumber);
				if (prevListNumber > currentListNumber
						|| prevIndexNumber > currentIndexNumber
						|| prevListNumber == -2 || prevIndexNumber == -2) {
					canAdd = false;
					break;
				} else if (prevListNumber == -1) {
					itemSet.addItem(str);
				} else if (prevListNumber < currentListNumber) {
					seq.addItemSet(itemSet);
					itemSet = new ItemSet();
					itemSet.addItem(str);
				} else if (prevListNumber == currentListNumber
						&& currentIndexNumber > prevIndexNumber) {
					itemSet.addItem(str);
				}
				prevListNumber = currentListNumber;
				//if (currentIndexNumber >= srcSequence.getPreviousListSize(prevListNumber) )
					//prevListNumber += 1;
				prevIndexNumber = currentIndexNumber;
			}
			if (canAdd) {
				seq.addItemSet(itemSet);
				if (seq.getAllItems().size() == expectedSeqSize) {
					sequences.add(seq);
				}
			}
		}
		return sequences;
	}

	// TODO: Venkat - This is for Transactions Pruning
	private ArrayList<Sequence> filterCandidates(
			ArrayList<Sequence> candidates, ArrayList<Transaction> transactions) {

		// Final Sequences:
		ArrayList<Sequence> filteredSequences = new ArrayList<Sequence>();
		// Output.printSequenceList(candidates);
		/*for (Transaction t : transactions) {
			Sequence s = t.getSequence();
			for (Sequence c : candidates) {
				if (s.isTheSequenceContainedInSameOrder(c)) {
					c.addCount();
				}
				Sequence cDash = getCDash(c); // removes first occurrence of
												// minMISItem from c
				if (s.isTheSequenceContainedInSameOrder(cDash)) {
					c.addTailCount();
				}

			}
		}*/
		for (Sequence c : candidates) {
			Integer count = SequenceIndex.getCountOfIntersectingIndexInOrder(c);
			if (count != null) {
				c.setCount(count);
			}
			Sequence cDash = getCDash(c); // removes first occurrence of
											// minMISItem from c
			Integer cDashcount = SequenceIndex.getCountOfIntersectingIndexInOrder(cDash);
			if (cDashcount != null) {
				cDash.setCount(cDashcount);
			}

		}
		
		
		// Check support
		for (Sequence c : candidates) {
			if (c.getCount() != 0) {
				if (((float) (c.getCount() / numTrans)) >= c.getLowestMIS()) {
					c.setSequenceSupport((float) c.getCount() / numTrans);
					if(!filteredSequences.contains(c))filteredSequences.add(c);
				}
			}
		}

		return filteredSequences;
	}

	private Sequence getCDash(Sequence c) {
		String minItem = c.getLowestMISItem();
		Sequence cDash;
		cDash = c.removeFirstOccurrenceAndReturnDuplicateCopy(minItem);
		return cDash;
	}

	private ArrayList<Sequence> doMsSPM(ArrayList<Sequence> fSequences) {

		ArrayList<Sequence> unPrunedSequences = new ArrayList<Sequence>();

		for (int i = 0; i < fSequences.size(); i++) {
			Sequence s1 = fSequences.get(i);
			float supL = s1.getSequenceSupport();
						
			for (int j = i+1; j < fSequences.size(); j++) {
				Sequence s2 = fSequences.get(j);
				float supH = s2.getSequenceSupport();
					
			
					s1 = fSequences.get(i).copy();
					s2 = fSequences.get(j).copy();
					mergeS1S2(unPrunedSequences,s1,s1);
					
					s1 = fSequences.get(i).copy();
					s2 = fSequences.get(j).copy();
					mergeS1S2(unPrunedSequences,s1,s2);
					s1 = fSequences.get(i).copy();
					s2 = fSequences.get(j).copy();
					mergeS1S2(unPrunedSequences,s2,s1);
			

			}

		}

		// Prune Step !!!! WRONG
		ArrayList<Sequence> prunedSequences = new ArrayList<Sequence>();
		for (Sequence s : unPrunedSequences) {
			if (isSequenceFrequent(s, fSequences)) {
				prunedSequences.add(s);
			}
		}
		// Output.printSequenceList(prunedSequences);

		return prunedSequences;
	}

	private void mergeS1S2(ArrayList<Sequence> unPrunedSequences,Sequence s1,Sequence s2){
		Sequence mergedSequence = null;
		if (isFirstMisMinimum(s1)) {
			ArrayList<Sequence> seqs = doSPMJoin(s1, s2);
			if (seqs != null)
				unPrunedSequences.addAll(seqs);
		} else if (isLastMisMinimum(s2)) {
			ArrayList<Sequence> seqs = doSPMReverseJoin(s1, s2);
			if (seqs != null)
				unPrunedSequences.addAll(seqs);
		} else {
			mergedSequence = doNormalJoin(s1, s2);
			if(mergedSequence!=null)
				unPrunedSequences.add(mergedSequence);
		}
	}
	private ArrayList<Sequence> doSPMReverseJoin(Sequence s1, Sequence s2) {
		ArrayList<String> s1Items = s1.getAllItems();
		ArrayList<String> s2Items = s2.getAllItems();
		ArrayList<Sequence> mergedSequences = new ArrayList<Sequence>();
		float supL=getSupportForDroppedItem(s1Items,s1Items.size()-2);
		float supH=getSupportForDroppedItem(s2Items,0);
		// Drop 1st index and 0th index of s2
		if (isSubsetEqual(s1Items.toArray(new String[] {}), s1Items.size()-2,0,
				s2Items.toArray(new String[] {}))
				&& MISMap.getMinSupport(s2.getFirstItem()) >= MISMap
						.getMinSupport(s1.getLastItem()) && Math.abs(supL-supH) <= (SDC+epsilon)) {
			if (s2.isFirstElementSeparate()) {
				mergedSequences.add(mergeSequences(s1, s2, 3)); //3-Prefix the item Separate
				if (s1.getSequenceSize() == 2 && s1.getSequenceLength() == 2
						&& compareFirstFirstLexic(s1, s2)) {
					mergedSequences.add(mergeSequences(s1, s2, 3));
				}
			} else if (((s1.getSequenceLength() == 2 && s1.getSequenceSize() == 1) && (compareFirstFirstLexic(
					s1, s2))) || (s1.getSequenceLength() > 2)) {
				mergedSequences.add(mergeSequences(s1, s2, 4)); // 4- Prefix a element of an item set
			}

		}

		return mergedSequences;
	}

	private boolean compareFirstFirstLexic(Sequence s1, Sequence s2) {
		String item1 = s1.getFirstItem();

		String item2 = s2.getFirstItem();

		return Integer.parseInt(item2)<Integer.parseInt(item1)? true : false;
	}

	private Sequence doNormalJoin(Sequence s1, Sequence s2) {
		ArrayList<String> s1Items = s1.getAllItems();
		ArrayList<String> s2Items = s2.getAllItems();
		Sequence mergedSequence = null;

		float supL=getSupportForDroppedItem(s1Items,0);
		float supH=getSupportForDroppedItem(s2Items,-1);
		// Drop 0th index
		if (isSubsetEqual(s1Items.toArray(new String[] {}), 0,-1,
				s2Items.toArray(new String[] {})) && Math.abs(supL-supH) <= (SDC+epsilon)) {
			if (s2.isLastElementSeparate())
				mergedSequence = mergeSequences(s1, s2, 1);
			else
				mergedSequence = mergeSequences(s1, s2, 2);

		}
		return mergedSequence;

	}

	/**
	 * 
	 * The reason for have List of Sequence is the special condition for 2!
	 * 
	 * @param s1
	 * @param s2
	 * @return
	 */
	private ArrayList<Sequence> doSPMJoin(Sequence s1, Sequence s2) {
		ArrayList<String> s1Items = s1.getAllItems();
		ArrayList<String> s2Items = s2.getAllItems();
		ArrayList<Sequence> mergedSequences = new ArrayList<Sequence>();
		
		
		float supL=getSupportForDroppedItem(s1Items,1);
		float supH=getSupportForDroppedItem(s2Items,-1);
		// Drop 1st index
		if (isSubsetEqual(s1Items.toArray(new String[] {}), 1,-1,
				s2Items.toArray(new String[] {}))
				&& MISMap.getMinSupport(s2.getLastItem()) >= MISMap
						.getMinSupport(s1.getFirstItem()) && Math.abs(supL-supH) <= (SDC+epsilon)) {
			if (s2.isLastElementSeparate()) {
				mergedSequences.add(mergeSequences(s1, s2, 1));
				if (s1.getSequenceSize() == 2 && s1.getSequenceLength() == 2
						&& compareLastLastLexic(s1, s2)) {
					mergedSequences.add(mergeSequences(s1, s2, 2));
				}
			} else if (((s1.getSequenceLength() == 2 && s1.getSequenceSize() == 1) && (compareLastLastLexic(
					s1, s2))) || (s1.getSequenceLength() > 2)) {
				mergedSequences.add(mergeSequences(s1, s2, 2));
			}

		}

		return mergedSequences;

	}

	private float getSupportForDroppedItem(ArrayList<String> s1Items, int i) {
		if(i==-1)
			return itemMinSups.get(s1Items.get(s1Items.size()-1));
		else		
			return itemMinSups.get(s1Items.get(i));
	}

	/**
	 * Do Level-2-Cadidates-SPM
	 * 
	 * 
	 * 
	 * @param arrayList
	 * @return
	 */

	private ArrayList<Sequence> doLevel2SPM(ArrayList<Sequence> level1Candidates) {

		ArrayList<Sequence> candidateSequences = new ArrayList<Sequence>();

		for (int i = 0; i < level1Candidates.size(); i++) {
			Sequence l = level1Candidates.get(i);
			String item1 = l.getFirstItem();
			float supL = l.getSequenceSupport();
			
				for (int j = 0; j < level1Candidates.size(); j++) {
					
					Sequence h = level1Candidates.get(j);
					String item2 = h.getFirstItem();
					float supH = h.getSequenceSupport();
					
					if ((supL >= MISMap.getMinSupport(item1) || supH >= MISMap.getMinSupport(item1)) 
							&& Math.abs(supH - supL) <= (SDC+epsilon)) { // DEBUG - SDC		
						candidateSequences.addAll(makeF2Candidates(item1, item2));
						candidateSequences.addAll(makeF2Candidates(item2, item1)); // IMP:: {x,y} != {y,x}
						//This is doubtful. The sequence could be useful. 
					
					}
				}

			}
		

		// PRUNE Starts here:
		/*ArrayList<Sequence> prunedSequences = new ArrayList<Sequence>();
		for (Sequence s : candidateSequences) {
			// p("############"+f1);
			if (isSequenceFrequent(s, level1Candidates)) {
				prunedSequences.add(s);
			}
		}*/
		// Output.printSequenceList(prunedSequences);

		return candidateSequences;
	}
	
	private List<Sequence> makeF2Candidates(String item1,String item2){
		List<Sequence> f2Candidates = new ArrayList<Sequence>();
			
		Sequence s1 = new Sequence();
		ItemSet is1 = new ItemSet();
		is1.addItem(item1);
		//is1.setCount(l.getCount()); // I don't know why I wrote
									// this
		ItemSet is2 = new ItemSet();
		is2.addItem(item2);
		//is2.setCount(h.getCount());
		s1.addItemSet(is1); // Independent
		s1.addItemSet(is2); // Independent
		s1.computeLowestMISItemSupport();
		if(!s1.isThereDuplicateItemInAnyItemSet())
			f2Candidates.add(s1);

		Sequence s2 = new Sequence();
		ItemSet is = new ItemSet();
		is.addItem(item1);
		is.addItem(item2);
		s2.addItemSet(is);
		s2.computeLowestMISItemSupport();
		if(!s2.isThereDuplicateItemInAnyItemSet())
			f2Candidates.add(s2);
		
		return f2Candidates;
	}

	/*
	 * public void sortItems(ArrayList<ItemSet> minSupItems){
	 * Comparator<ItemSet>generateSizeMinus1Sequences minSupComparator = new
	 * Comparator<ItemSet>() { public int compare(ItemSet item1, ItemSet item2)
	 * { if (item1.getMinSup() < item2.getMinSup()) return -1; if
	 * (item1.getMinSup() > item2.getMinSup()) return 1; return 0; } };
	 * Collections.sort(minSupItems, minSupComparator); }
	 */

	public static void main(String[] args) {

		MSGSP ms = new MSGSP();
		//ms.execute(new File("test-data-1/small-data-1/data-1.txt"), new File("test-data-1/small-data-1/para1-1.txt"),true);
		//ms = new MSGSP();
		//ms.execute(new File("test-data-1/small-data-1/data-1.txt"), new File("test-data-1/small-data-1/para1-2.txt"),true);
		//ms = new MSGSP();
		ms.execute(new File("test-data-1/large-data-2/data2.txt"), new File("test-data-1/large-data-2/para2-1.txt"),true);
		//ms = new MSGSP();
		//ms.execute(new File("test-data-1/large-data-2/data2.txt"), new File("test-data-1/large-data-2/para2-2.txt"),true);		
		
	}

	// /TO BE REMOVED
	private static Sequence getSequenceForTest() {
		Sequence sequence = new Sequence();
		ItemSet itemSet1 = new ItemSet();
		itemSet1.addItem("2");
		sequence.addItemSet(itemSet1);

		ItemSet itemSet2 = new ItemSet();
		itemSet2.addItem("5");
		itemSet2.addItem("13");

		sequence.addItemSet(itemSet2);
		/*ItemSet itemSet3 = new ItemSet();
		itemSet3.addItem("7");
		 itemSet2.addItem("4"); 
		sequence.addItemSet(itemSet3);
		*/return sequence;
	}

	private static Sequence getSequenceForTest1() {
		Sequence sequence = new Sequence();
		ItemSet itemSet1 = new ItemSet();
		itemSet1.addItem("5");
		
		sequence.addItemSet(itemSet1);

		ItemSet itemSet2 = new ItemSet();
		itemSet2.addItem("7");
		/* itemSet2.addItem("4"); */
		sequence.addItemSet(itemSet2);
		/*ItemSet itemSet3 = new ItemSet();
		itemSet3.addItem("3");
		sequence.addItemSet(itemSet3);
*/
		return sequence;
	}
}package dm.algorithms.msgsp;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class Output {

	public static void printSequenceList(List<Sequence> sequences){
		String format="";
		for(Sequence s:sequences){
			format=format+s.getFormattedSequence()+" ";
		}
		System.out.println(format);
	}
	
	public static void printForBing(List<Sequence> sequences,int fCount){
		String format="";
		format=format+"\nThe number of length "+fCount+" sequential patterns is "+sequences.size()+"\n";
		for(Sequence s:sequences){
		format=format+"Pattern: "+s.getFormattedSequence()+" Count: "+s.getCount()+"\n";
			}
		System.out.println(format);
		}
	
	public static String formatForBing(List<Sequence> sequences,int fCount){
		String format="";
		format=format+"\nThe number of length "+fCount+" sequential patterns is "+sequences.size()+"\n";
		for(Sequence s:sequences){
		format=format+"Pattern: "+s.getFormattedSequence()+" Count: "+s.getCount()+"\n";
			}
	
		return format;
		}
	
	public static void writeToFile(String path,HashMap<Integer, ArrayList<Sequence>> sequencePatterns){
		try {
			FileWriter fw = new FileWriter(new File(path));
			 for(int i=1;i<sequencePatterns.size();i++){
				 fw.write(formatForBing(sequencePatterns.get(i),i)+"\n\n");
				 }
			fw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
package dm.algorithms.msgsp;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import dm.algorithms.msgsp.model.MISMap;

public class Sequence implements Serializable {

	private ArrayList<ItemSet> itemSet = new ArrayList<ItemSet>();
	private transient int count = 0; // To be used by candidates and to create Final
	// Frequencies
	private transient int restCount = 0; // same as above.

	private transient float lowestMIS = 0; // "Minimum support" for a sequence
	private transient float sequenceSupport = 0; // Actual support - Transaction
	private transient String minMISItem = "";

	public String getMinMISItem() {
		return minMISItem;
	}

	public void setMinMISItem(String minMISItem) {
		this.minMISItem = minMISItem;
	}

	public float getSequenceSupport() {
		return sequenceSupport;
	}

	public void setSequenceSupport(float sequenceSupport) {
		this.sequenceSupport = sequenceSupport;
	}

	public ArrayList<ItemSet> getItemSet() {
		return itemSet;
	}

	public void setItemSet(ArrayList<ItemSet> itemSet) {
		this.itemSet = itemSet;
	}

	public int getCount() {
		return this.count;
	}

	public void setCount(int count) {
		this.count = count;
	}

	public int getRestCount() {
		return restCount;
	}

	public void setRestCount(int restCount) {
		this.restCount = restCount;
	}

	public float getLowestMIS() {
		return lowestMIS;
	}

	public void setLowestMIS(float minSup) {
		this.lowestMIS = minSup;
	}

	public ArrayList<String> getAllItems() {
		ArrayList<String> items = new ArrayList<String>();
		for (ItemSet i : this.itemSet)
			items.addAll(i.getItems());
		return items;

	}

	/**
	 * Returns number of elements(length) of a sequence
	 * 
	 * @return
	 */
	public int getSequenceLength() {
		int size = 0;
		for (ItemSet i : getItemSet())
			size = size + i.getItems().size();
		return size;
	}

	/**
	 * Returns number of ItemSets(size) present
	 * 
	 * @return
	 */
	public int getSequenceSize() {
		int length = 0;
		return this.itemSet.size();
	}

	/**
	 * 
	 * Checks if last item in this sequecne is separate
	 * 
	 * @return
	 */
	public boolean isLastElementSeparate() {
		return this.itemSet.get(this.itemSet.size() - 1).getItems().size() == 1 ? true
				: false;
	}

	/**
	 * 
	 * Get last itemset elements in this sequence
	 * 
	 * @return
	 */

	public ArrayList<String> getLastItemSetElements() {
		return this.itemSet.get(this.itemSet.size() - 1).getItems();
	}

	/**
	 * 
	 * Get last itemset in this sequence
	 * 
	 * @return
	 */

	public ItemSet getLastItemSet() {
		return this.itemSet.get(this.itemSet.size() - 1);
	}

	/**
	 * 
	 * Get last item in this sequence
	 * 
	 * @return
	 */

	public String getLastItem() {
		ArrayList<String> temp = this.itemSet.get(this.itemSet.size() - 1)
				.getItems();
		return temp.get(temp.size() - 1);
	}

	/**
	 * Get the first itemset in this sequence
	 * 
	 * @return
	 */
	public ArrayList<String> getFirstItemSetElements() {
		return this.itemSet.get(0).getItems();
	}

	/**
	 * Returns the first itemset in this sequence
	 * 
	 * @return
	 */
	public ItemSet getFirstItemSet() {
		return this.itemSet.get(0);
	}

	/**
	 * Get the first itemset in this sequence
	 * 
	 * @return
	 */
	public String getFirstItem() {
		return this.itemSet.get(0).getItems().get(0);
	}

	/**
	 * Adds an itemset into the sequence
	 * 
	 * @param i
	 */
	public void addItemSet(ItemSet i) {
		this.itemSet.add(i);
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Sequence s2 = (Sequence) obj;
		if(this.getSequenceSize()!=s2.getSequenceSize()) return false;
		if (this.itemSet.equals(s2.getItemSet()))
			return true;
		return false;

	}

	public String getFormattedSequence() {
		String format = "<";
		for (ItemSet i : this.getItemSet())
			format = format + "{" + i.getFormattedItemString() + "}";
		return format + ">";
	}

	public void computeLowestMISItemSupport() {
		float minSup = MISMap.getMinSupport(this.getFirstItem());
		for (String s : this.getAllItems()) {
			if (MISMap.getMinSupport(s) < minSup)
				minSup = MISMap.getMinSupport(s);

		}
		this.setLowestMIS(minSup);

	}

	// Get the Item with min MIS;
	public String getLowestMISItem() {
		String minMISItem = "";
		for (String s : this.getAllItems()) {
			if (MISMap.getMinSupport(s) == lowestMIS)
				minMISItem = s;
		}
		this.minMISItem = minMISItem;
		return minMISItem;
	}

	public boolean isTheSequenceContainedInSameOrder(Sequence seq) {

		int prevMatchingItem = -1;
		for (int i = 0; i < seq.getSequenceSize(); i++) {
			boolean noMatchFound = true;
			for (int j = prevMatchingItem+1; j < this.getSequenceSize(); j++) {
				if (this.getItemSet().get(j).contains(seq.getItemSet().get(i))) {
					prevMatchingItem = j;
					noMatchFound = false;
					break;
				}
			}
			if (noMatchFound) {
				return false;
			}
		}

		return true;
	}

	public void addCount() {
		this.count++;
	}

	public void addTailCount() {
		this.restCount++;
	}

	public Sequence removeFirstOccurrenceAndReturnDuplicateCopy(String minItem) {
		Sequence seq = this.copy();
		Iterator<ItemSet> seqItemItr = seq.getItemSet().iterator();
		boolean notRemoved = true;
		while (seqItemItr.hasNext() && notRemoved) {
			ItemSet itemSet = (ItemSet) seqItemItr.next();
			Iterator<String> itemValItr = itemSet.getItems().iterator();
			while (itemValItr.hasNext()) {
				String val = (String) itemValItr.next();
				if (val.equals(minItem)) {
					itemValItr.remove();
					notRemoved = false;
				}
			}
		}

		Iterator<ItemSet> seqItemItr1 = seq.getItemSet().iterator();
		while (seqItemItr1.hasNext()) {
			ItemSet itemSet = (ItemSet) seqItemItr1.next();
			if (itemSet.getItems().size() <= 0) {
				seqItemItr1.remove();
				break;
			}
		}

		return seq;
	}

	public int checkNthElementListNumber(String str, int fromPosition,
			int nthPosition) {
		if (fromPosition < 0)
			fromPosition = 0;
		int lastSeenElement = -2;
		for (int i = fromPosition; i < getItemSet().size(); i++) {
			if (getItemSet().get(i).getItems().contains(str)) {
				nthPosition -= 1;
				lastSeenElement = i;
				if (nthPosition == 0)
					return lastSeenElement;
			}
		}
		return lastSeenElement;
	}

	public int checkNthElementIndexNumber(String str, int fromPosition,
			int nthPosition) {
		if (fromPosition < 0)
			fromPosition = 0;
		int lastSeenElement = -2;
		for (int i = fromPosition; i < getAllItems().size(); i++) {
			if (getAllItems().get(i).equalsIgnoreCase(str)) {
				nthPosition -= 1;
				lastSeenElement = i;
				if (nthPosition == 0)
					return lastSeenElement;
			}
		}
		return lastSeenElement;
	}

	public Sequence copy() {
		Sequence obj = null;
		try {
			ByteArrayOutputStream bos = new ByteArrayOutputStream();
			ObjectOutputStream oos = new ObjectOutputStream(bos);
			oos.writeObject(this);
			oos.flush();
			oos.close();
			bos.close();
			byte[] byteData = bos.toByteArray();
			ByteArrayInputStream bais = new ByteArrayInputStream(byteData);
			obj = (Sequence) new ObjectInputStream(bais).readObject();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (ClassNotFoundException cnfe) {
			cnfe.printStackTrace();
		}
		return obj;
	}

	public int getPreviousListSize(int prevListNumber) {
		try {
			return this.getItemSet().get(prevListNumber).getItems().size();
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println(prevListNumber);
		}
		return 0;
	}

	public int checkNumberOfSuchElement(String str) {
		int count = 0;
		for (String itemStr : this.getAllItems()) {
			if (itemStr.equals(str))
				count += 1;
		}
		return count;
	}

	@Override
	public String toString() {
		return this.getFormattedSequence();
	}

	public boolean isThereDuplicateItemInAnyItemSet() {
		for(ItemSet itemSet : this.getItemSet()){
			int countAsList = itemSet.getItems().size();
			Set<String> itemSetAsSet = new HashSet<String>(itemSet.getItems());
			int countAsSet = itemSetAsSet.size();
			if(countAsList != countAsSet)
				return true;			
		}
		return false;
	}

	public int getItemSetNumberGivenItemIndex(int currentIndexNumber) {
		int count = -1;
		for(int i=0;i<this.getItemSet().size();i++){
			count += ((this.getItemSet().get(i).getItems().size()));
			if(count>=currentIndexNumber)
				return i;
		}
		return -2;
	}

	public boolean isFirstElementSeparate() {	
		return this.itemSet.get(0).getItems().size() == 1 ? true
			: false;
		

	}

	public void prefixItemSet(ItemSet itemset2) {
		this.itemSet.add(0,itemset2);
		
	}

}
package dm.algorithms.msgsp;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public class TestGSP {

	public static void printGSP(HashMap<Integer,ArrayList<Sequence>> sp){
		
	}
	

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		ArrayList<String> x = new ArrayList<String>();
		x.add("A");
		x.add("B");
		ArrayList<String> x1 = new ArrayList<String>();

		x1.add("A");
		x1.add("B");

		ArrayList<ItemSet> i1 = new ArrayList<ItemSet>();
		ArrayList<ItemSet> i2 = new ArrayList<ItemSet>();
		ItemSet i11 = new ItemSet();
		i11.setItems(x);
		ItemSet i12 = new ItemSet();
		i11.setItems(x1);
		i1.add(i12);
		i1.add(i11);
		i2.add(i12);
		i2.add(i11);
		
		Sequence sequence = getSequenceForTest();
		System.out.println(sequence.getFormattedSequence());

		//allPossibleCustomPermutation(sequence.getAllItems());
		
		//testRemoveFirstOccurence(sequence);
		
	}

	private static void testRemoveFirstOccurence(Sequence sequence) {
		System.out.println(sequence.getFormattedSequence());
		Sequence seq1 = removeFirstOccurrenceOf(sequence, "4");
		System.out.println(seq1.getFormattedSequence());
		System.out.println(sequence.getFormattedSequence());
	}
	
	private static Sequence getSequenceForTest() {
		Sequence sequence = new Sequence();
		ItemSet itemSet1 = new ItemSet();
		itemSet1.addItem("1");
		itemSet1.addItem("2");
		itemSet1.addItem("3");
		sequence.addItemSet(itemSet1);

		ItemSet itemSet2 = new ItemSet();
		itemSet2.addItem("5");
		sequence.addItemSet(itemSet2);

		ItemSet itemSet3 = new ItemSet();
		itemSet3.addItem("6");
		sequence.addItemSet(itemSet3);
		return sequence;
	}
	
	public static Sequence removeFirstOccurrenceOf(Sequence seqInput , String minItem) {
		Sequence seq = seqInput.copy();
		Iterator seqItemItr = seq.getItemSet().iterator();
		while(seqItemItr.hasNext()){
			ItemSet itemSet = (ItemSet) seqItemItr.next();
			Iterator itemValItr = itemSet.getItems().iterator();
			while(itemValItr.hasNext()){
				String val = (String) itemValItr.next();
				if(val.equals(minItem)){			
					itemValItr.remove();
					break;
				}
			}
		}
		
		Iterator seqItemItr1 = seq.getItemSet().iterator();
		while(seqItemItr1.hasNext()){
			ItemSet itemSet = (ItemSet) seqItemItr1.next();
			if(itemSet.getItems().size() <= 0){
				seqItemItr1.remove();
				break;
			}
		}
		
		
		return seq;
	};


	private static Sequence makeNewItemSetIfAlreadyPresent(Sequence seq) {
		Sequence seqNew = new Sequence();
		for(ItemSet itemSet : seq.getItemSet()){
			ItemSet itemSet1 =  new ItemSet();
			ItemSet itemSet2 = null;
			HashMap<String,Integer> map = new HashMap<String,Integer>();
			for(String str : itemSet.getItems()){
				if(!map.containsKey(str)){
					map.put(str, 1);
					itemSet1.addItem(str);
				}else if(map.containsKey(str)){
					itemSet2= new ItemSet();
					itemSet2.addItem(str);
				}
			}
			seqNew.addItemSet(itemSet1);
			if(itemSet2 != null){
				seqNew.addItemSet(itemSet2);
			}
		}
		return seqNew;
	}


	private static List<ItemSet> allPossibleCustomPermutation(List<String> strs) {
		
		Set<List<String>> permutedIntegers = permute(strs);
		List<ItemSet> permuted = new ArrayList<ItemSet>();
		for (List<String> perm : permutedIntegers) {
			perm.remove(perm.size()-1);			
			List<String> permStr = perm;
			//System.out.println(permStr);
			permuted.add(makeItemPair(permStr));			
		}
		return permuted;
	}
	
	public static Set<List<String>> permute(List<String> input) {
		Set<List<String>> output = new HashSet<List<String>>();
		if (input.isEmpty()) {
			output.add(new ArrayList<String>());
			return output;
		}
		List<String> list = new ArrayList<String>(input);
		String head = list.get(0);
		for (List<String> permutations : permute(list.subList(1, list.size()))) {
			List<List<String>> subLists = new ArrayList<List<String>>();
			for (int i = 0; i <= permutations.size(); i++) {
				List<String> subList = new ArrayList<String>();
				subList.addAll(permutations);
				subList.add(i, head);
				subLists.add(subList);
			}
			output.addAll(subLists);
		}
		return output;
	}

	private static ItemSet makeItemPair(List<String> obtainedValues) {
		ItemSet itemPair = new ItemSet();
		for (String str : obtainedValues) {
			itemPair.addItem(str);
		}
		return itemPair;
	}


}
package dm.algorithms.msgsp;


public class Transaction {

	private long tid; //For this Customer id == transaction Id
	private Sequence sequence = new Sequence();

	public Transaction() {

	}

	
	public Transaction(long tid, Sequence transactionSet) {
		super();
		this.tid = tid;
		this.sequence=transactionSet;
	}

	public long getTid() {
		return tid;
	}

	public void setTid(long tid) {
		this.tid = tid;
	}

	public boolean isSequenceFrequent(Sequence s) {

		return false;
	}

	public Sequence getSequence() {
		return sequence;
	}

	public void setSequence(Sequence sequence) {
		this.sequence = sequence;
	}

}package dm.algorithms.msgsp;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Util {
	
	public static List<ItemSet> allPossibleCustomPermutation(List<String> strs) {		
		List<List<String>> permutedIntegers = permute(strs);
		List<ItemSet> permuted = new ArrayList<ItemSet>();
		for (List<String> perm : permutedIntegers) {
			perm.remove(perm.size()-1);			
			List<String> permStr = perm;
			permuted.add(makeItemPair(permStr));			
		}
		return permuted;
	}

	private static ItemSet makeItemPair(List<String> obtainedValues) {
		ItemSet itemPair = new ItemSet();
		for (String str : obtainedValues) {
			itemPair.addItem(str);
		}
		return itemPair;
	}
	
	private static List<List<String>> permute(List<String> input) {
		List<List<String>> output = new ArrayList<List<String>>();
		if (input.isEmpty()) {
			output.add(new ArrayList<String>());
			return output;
		}
		List<String> list = new ArrayList<String>(input);
		String head = list.get(0);
		for (List<String> permutations : permute(list.subList(1, list.size()))) {
			List<List<String>> subLists = new ArrayList<List<String>>();
			for (int i = 0; i <= permutations.size(); i++) {
				List<String> subList = new ArrayList<String>();
				subList.addAll(permutations);
				subList.add(i, head);
				subLists.add(subList);
			}
			output.addAll(subLists);
		}
		return output;
	}
}
package dm.algorithms.msgsp.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public class MISMap {
	public static Map<String,Float> minSupportMap = new HashMap<String,Float>();
	
	public static Map<String, Float> getMinSupportMap() {
		return minSupportMap;
	}
	
	public static void addNewMinSupport(String item) {
		float count = 1;
		if (minSupportMap.containsKey(item)) {
			count = minSupportMap.get(item) + 1;
		}
		minSupportMap.put(item, count);
	}

	public static float getMinSupport(String item) {
		if (minSupportMap.containsKey(item))
			return minSupportMap.get(item).floatValue();
		return (float) 0;
	}

	public void print() {
		for (Map.Entry<String, Float> entry : minSupportMap.entrySet()) {
			System.out.println(entry.getKey()+ " = "
					+ entry.getValue());
		}
	}
	
	public static List<String> getItemsInAscOrderOfMinSup(){
		ValueComparator valComparator =  new ValueComparator(minSupportMap);
        TreeMap<String,Float> sortedMapBasedOnValue = new TreeMap<String,Float>(valComparator);
        sortedMapBasedOnValue.putAll(minSupportMap);
        List<String> sortedString = new ArrayList<String>();
        for(String str : sortedMapBasedOnValue.keySet()){
        	sortedString.add(str);
        }       
        return sortedString;
	}
	
	
	
	

}package dm.algorithms.msgsp.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import dm.algorithms.msgsp.ItemSet;
import dm.algorithms.msgsp.Sequence;
import dm.algorithms.msgsp.Transaction;

public class SequenceIndex {

	private static Map<String, List<SequenceIndexValue>> seqIndex = new HashMap<String, List<SequenceIndexValue>>();

	public static List<SequenceIndexValue> getSequenceIndex(String key) {
		return seqIndex.get(key);
	}

	public static void setSequenceIndex(String key, List<SequenceIndexValue> indexes) {
		if (getSequenceIndex(key) != null) {
			getSequenceIndex(key).addAll(indexes);
		} else {
			seqIndex.put(key, indexes);
		}
	}

	public static void setSequenceIndex(String key, SequenceIndexValue index) {
		if (getSequenceIndex(key) != null) {
			getSequenceIndex(key).add(index);
		} else {
			List<SequenceIndexValue> seqIndexes = new ArrayList<SequenceIndexValue>();
			seqIndexes.add(index);
			setSequenceIndex(key, seqIndexes);
		}
	}
	
	static int count=0;
	
	public static Integer getCountOfIntersectingIndexInOrder(Sequence sequence) {
		List<SequenceIndexValue> intersectingSeqIndexes = new ArrayList<SequenceIndexValue>();
		for (ItemSet itemSet : sequence.getItemSet()) {
			boolean itemSetIncremented = true;
			for (String str : itemSet.getItems()) {
				List<SequenceIndexValue> currentSeqIndexVals = getSequenceIndex(str);
				if (intersectingSeqIndexes.size() != 0) {
					intersectingSeqIndexes = matchIndex(intersectingSeqIndexes, currentSeqIndexVals, itemSetIncremented);
				} else if (currentSeqIndexVals != null) {
					List<SequenceIndexValue> seqIndValCopies = getSeqIndexValuesCopy(currentSeqIndexVals);
					intersectingSeqIndexes.addAll(seqIndValCopies);
				}
				itemSetIncremented = false;
			}
		}

		return count;
	}

	private static List<SequenceIndexValue> getSeqIndexValuesCopy(List<SequenceIndexValue> currentSeqIndexVals) {
		List<SequenceIndexValue> seqIndexes = new ArrayList<SequenceIndexValue>();
		for (SequenceIndexValue seqIndVal : currentSeqIndexVals) {
			seqIndexes.add(seqIndVal.copy());
		}
		return seqIndexes;
	}

	private static List<SequenceIndexValue> matchIndex(
			List<SequenceIndexValue> intersectingSeqIndexes,
			List<SequenceIndexValue> currSeqIndexes, boolean itemSetIncremented) {
		Iterator<SequenceIndexValue> iterate = intersectingSeqIndexes
				.iterator();
		count = 0;
		while (iterate.hasNext()) {
			SequenceIndexValue intersectingSeqIndex = iterate.next();
			boolean matched = false;
			for (int k = 0; k < currSeqIndexes.size(); k++) {
				SequenceIndexValue seqIndVal = currSeqIndexes.get(k);

				if (seqIndVal.getListNum() < intersectingSeqIndex.getListNum())
					continue;
				if (seqIndVal.getListNum() > intersectingSeqIndex.getListNum())
					break;

				if (seqIndVal.getListNum() == intersectingSeqIndex.getListNum()) {
					if (!itemSetIncremented
							&& seqIndVal.getItemSetNum() == intersectingSeqIndex
									.getItemSetNum()
							|| (itemSetIncremented && seqIndVal.getItemSetNum() > intersectingSeqIndex
									.getItemSetNum())) {
						if (seqIndVal.getArrPosNum() > intersectingSeqIndex
								.getArrPosNum()) {
							intersectingSeqIndex.setArrPosNum(seqIndVal
									.getArrPosNum());
							intersectingSeqIndex.setItemSetNum(seqIndVal
									.getItemSetNum());
							matched = true;
							break;
						}
					}
				}
			}
			if (!matched) {
				iterate.remove();
			}
			if(matched){
				count+=1;
			}
			// k-=1;
		}
		//System.out.println("matching count = "+count);
		return intersectingSeqIndexes;
	}

	public static void createSequenceIndex(List<Transaction> transactions) {
		for (int i = 0; i < transactions.size(); i++) {
			Sequence seq = transactions.get(i).getSequence();
			int listNumber = i;
			int arrayListPosition = 0;
			List<ItemSet> itemSets = seq.getItemSet();
			for (int j = 0; j < itemSets.size(); j++) {
				ItemSet itemSet = itemSets.get(j);
				int itemSetNumber = j;
				for (int k = 0; k < itemSet.getItems().size(); k++) {
					String item = itemSet.getItems().get(k);
					SequenceIndexValue indexVal = new SequenceIndexValue();
					indexVal.setListNum(listNumber);
					indexVal.setItemSetNum(itemSetNumber);
					indexVal.setArrPosNum(arrayListPosition);
					SequenceIndex.setSequenceIndex(item, indexVal);
					arrayListPosition += 1;
				}
			}
		}
	}

	public static void print() {
		for (Entry<String, List<SequenceIndexValue>> entry : seqIndex.entrySet()) {
			System.out.println(entry.getKey() + " = " + entry.getValue());
		}
	}
}
package dm.algorithms.msgsp.model;

public class SequenceIndexValue {
	
	private int listNum;
	private int itemSetNum;
	private int arrPosNum;

	public int getListNum() {
		return listNum;
	}

	public void setListNum(int listNum) {
		this.listNum = listNum;
	}

	public int getItemSetNum() {
		return itemSetNum;
	}

	public void setItemSetNum(int itemSetNum) {
		this.itemSetNum = itemSetNum;
	}

	public int getArrPosNum() {
		return arrPosNum;
	}

	public void setArrPosNum(int arrPosNum) {
		this.arrPosNum = arrPosNum;
	}

	@Override
	public String toString() {
		return listNum + " " + itemSetNum + " " + arrPosNum;
	}

	public SequenceIndexValue copy() {
		SequenceIndexValue sequenceIndexValue = new SequenceIndexValue();
		sequenceIndexValue.setArrPosNum(this.getArrPosNum());
		sequenceIndexValue.setItemSetNum(this.getItemSetNum());
		sequenceIndexValue.setListNum(this.getListNum());
		return sequenceIndexValue;
	}
	
	

}
package dm.algorithms.msgsp.model;

import java.util.Comparator;
import java.util.Map;

class ValueComparator implements Comparator<String> {

    Map<String, Float> base;
    public ValueComparator(Map<String, Float> base) {
        this.base = base;
    }

    public int compare(String a, String b) {
        if (base.get(a) >= base.get(b)) {
            return 1;
        } else {
            return -1;
        }
    }
}